<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>PV Layout Tool (Multi Areas + Walkways + Auto-Fill)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <style>
    html, body { height: 100%; margin: 0; font-family: Arial, sans-serif; }
    #map { height: 100%; width: 100%; }

    .panel{
      position:absolute; top:12px; left:12px;
      background:rgba(255,255,255,0.94);
      padding:10px 12px; border-radius:12px;
      box-shadow:0 8px 22px rgba(0,0,0,0.18);
      z-index:5; width:420px;
      max-height:calc(100% - 24px);
      overflow:auto;
    }
    .row{ display:flex; gap:8px; margin:8px 0; }
    .row>div{ flex:1; }
    label{ font-size:12px; color:#222; display:block; margin-bottom:4px; }
    input,select{
      width:100%; padding:8px; box-sizing:border-box;
      border-radius:10px; border:1px solid #ccc;
      font-size:14px;
    }
    button{
      width:100%; padding:10px; cursor:pointer; margin-top:8px;
      border-radius:12px; border:1px solid #bbb; background:#f5f5f5;
      font-weight:600;
    }
    button:hover{ background:#eee; }
    button.primary{ background:#111; color:#fff; border:0; }
    button.primary:hover{ background:#000; }
    button.danger{ background:#c62828; color:#fff; border:0; }
    button.danger:hover{ background:#a61f1f; }

    small{ color:#444; line-height:1.35; display:block; margin-top:6px; }
    .pill{
      display:inline-block; padding:3px 8px; border-radius:999px;
      background:#f0f0f0; border:1px solid #ddd; font-size:12px;
      margin-right:6px; margin-top:6px;
    }
    .stats{ margin-top:10px; font-weight:bold; }
    .hint{ font-weight:normal; margin-top:6px; color:#333; }
    .sectionTitle{
      font-weight:bold; margin-top:10px;
      padding-top:8px; border-top:1px solid #e5e5e5;
    }
    .selectedBadge{
      display:inline-block; margin-left:8px;
      padding:3px 8px; border-radius:999px;
      border:1px solid #ddd; background:#fafafa; font-size:12px;
    }
  </style>
</head>

<body>
  <div class="panel">
    <div class="sectionTitle" style="border-top:none; padding-top:0; margin-top:0;">
      Find location
    </div>

    <div class="row">
      <div style="flex:1.6;">
        <label>Coordinates (lat, lng)</label>
        <input id="coords" type="text" value="-1.2981371, 36.8907759" placeholder="-1.2981371, 36.8907759">
      </div>
      <div style="flex:0.9;">
        <label>&nbsp;</label>
        <button id="btnGoCoords" style="margin-top:0;">Go</button>
      </div>
    </div>
    <small>Paste as <b>lat, lng</b> then click Go.</small>

    <div class="sectionTitle">
      Panel / Layout
      <span class="selectedBadge" id="selInfo">Selected area: none</span>
    </div>

    <div class="row">
      <div>
        <label>Panel Length (m)</label>
        <input id="pLen" type="number" step="0.001" value="2.279">
      </div>
      <div>
        <label>Panel Width (m)</label>
        <input id="pWid" type="number" step="0.001" value="1.134">
      </div>
    </div>

    <div class="row">
      <div>
        <label>Gap between panels (m)</label>
        <input id="gap" type="number" step="0.001" value="0.02">
      </div>
      <div>
        <label>Edge setback (m)</label>
        <input id="setback" type="number" step="0.01" value="0.30">
      </div>
    </div>

    <div class="row">
      <div>
        <label>Rotation Mode</label>
        <select id="rotMode">
          <option value="auto" selected>Auto (longest edge)</option>
          <option value="manual">Manual angle</option>
          <option value="none">No rotation (0Â°)</option>
        </select>
      </div>
      <div>
        <label>Manual angle (deg, from East/X)</label>
        <input id="manualAngle" type="number" step="0.1" value="0">
      </div>
    </div>

    <div class="sectionTitle">Draw / Actions</div>

    <div class="row">
      <div><button id="btnDrawArea">Draw Roof / Ground Area</button></div>
      <div><button id="btnDrawWalk">Draw Walkway / No-Go</button></div>
    </div>

    <div class="row">
      <div><button id="btnStopDraw">Stop Drawing</button></div>
      <div><button id="btnDeleteSelected">Delete Selected</button></div>
    </div>

    <button class="primary" id="btnFill">Auto-fill Panels (Selected Area)</button>

    <div class="row">
      <div><button id="btnClearAreaPanels">Clear Panels (Selected)</button></div>
      <div><button id="btnExport">Export JSON</button></div>
    </div>

    <button class="danger" id="btnReset">Reset Everything</button>

    <small>
      <span class="pill">1</span> Click <b>Draw Roof / Ground Area</b> and draw polygon (click first point to close).<br/>
      <span class="pill">2</span> Click the polygon to <b>select</b> it (thicker outline).<br/>
      <span class="pill">3</span> Click <b>Auto-fill</b>. Then draw the next side and repeat (nothing disappears).<br/>
      <span class="pill">4</span> Use <b>Walkway / No-Go</b> polygons for access paths, tanks, skylights; panels avoid them.
    </small>

    <div id="stats" class="stats"></div>
    <div id="hint" class="hint"></div>
  </div>

  <div id="map"></div>

  <script>
    // =========================
    // GLOBALS
    // =========================
    let map, drawingManager;
    let pinMarker = null;

    const DRAW_NONE = null;
    const DRAW_AREA = "area";
    const DRAW_WALK = "walk";
    let drawMode = DRAW_NONE;

    // Areas: { id, poly, panels[] }
    const areas = [];
    // Walkways / No-Go polygons
    const walkways = [];

    // Selected: { type: 'area', ref: areaObj } OR { type: 'walk', ref: polygon }
    let selected = null;

    // =========================
    // UI HELPERS
    // =========================
    function setHint(t){ document.getElementById("hint").innerText = t || ""; }
    function setStats(t){ document.getElementById("stats").innerText = t || ""; }

    function updateSelectedInfo(){
      const el = document.getElementById("selInfo");
      if(!selected) el.innerText = "Selected area: none";
      else if(selected.type === "area") el.innerText = `Selected area: ${selected.ref.id}`;
      else el.innerText = "Selected: walkway/no-go";
    }

    function clearSelectionStyles(){
      for(const a of areas){
        a.poly.setOptions({ strokeWeight: 2 });
      }
      for(const w of walkways){
        w.setOptions({ strokeWeight: 2 });
      }
    }

    function selectArea(areaObj){
      selected = { type:"area", ref: areaObj };
      clearSelectionStyles();
      areaObj.poly.setOptions({ strokeWeight: 4 });
      updateSelectedInfo();
      setHint("Area selected. Click Auto-fill Panels.");
    }

    function selectWalkway(poly){
      selected = { type:"walk", ref: poly };
      clearSelectionStyles();
      poly.setOptions({ strokeWeight: 4 });
      updateSelectedInfo();
      setHint("Walkway/no-go selected. You can delete it if needed.");
    }

    function unselectAll(){
      selected = null;
      clearSelectionStyles();
      updateSelectedInfo();
    }

    // =========================
    // COORDS JUMP
    // =========================
    function goToCoords() {
      const raw = (document.getElementById("coords").value || "").trim();
      const parts = raw.split(/[\s,]+/).filter(Boolean);
      if (parts.length < 2) { alert("Enter coordinates as: -1.2981371, 36.8907759"); return; }

      const lat = parseFloat(parts[0]);
      const lng = parseFloat(parts[1]);
      if (!Number.isFinite(lat) || !Number.isFinite(lng) || lat < -90 || lat > 90 || lng < -180 || lng > 180) {
        alert("Invalid coordinates."); return;
      }

      const pos = new google.maps.LatLng(lat, lng);
      map.panTo(pos);
      map.setZoom(Math.max(map.getZoom() || 18, 20));

      if (pinMarker) pinMarker.setMap(null);
      pinMarker = new google.maps.Marker({ position: pos, map, title: `${lat.toFixed(6)}, ${lng.toFixed(6)}` });

      setHint(`Pinned: ${lat.toFixed(6)}, ${lng.toFixed(6)}.`);
    }

    // =========================
    // SIMPLE GEO UTILS (approx)
    // =========================
    function metersToDegreesLat(m){ return m / 111320.0; }
    function metersToDegreesLng(m, atLatDeg){
      const c = Math.cos(atLatDeg * Math.PI/180);
      return m / (111320.0 * Math.max(0.00001, c));
    }

    function polygonToPath(poly){
      return poly.getPath().getArray().map(p => ({lat:p.lat(), lng:p.lng()}));
    }

    function polygonBounds(path){
      let minLat=Infinity,maxLat=-Infinity,minLng=Infinity,maxLng=-Infinity;
      for(const p of path){
        minLat=Math.min(minLat,p.lat); maxLat=Math.max(maxLat,p.lat);
        minLng=Math.min(minLng,p.lng); maxLng=Math.max(maxLng,p.lng);
      }
      return {minLat,maxLat,minLng,maxLng};
    }

    function pointInPoly(pt, polyPath){
      let x = pt.lng, y = pt.lat;
      let inside = false;
      for(let i=0, j=polyPath.length-1; i<polyPath.length; j=i++){
        const xi=polyPath[i].lng, yi=polyPath[i].lat;
        const xj=polyPath[j].lng, yj=polyPath[j].lat;
        const intersect = ((yi>y)!==(yj>y)) && (x < (xj-xi)*(y-yi)/((yj-yi)||1e-12) + xi);
        if(intersect) inside = !inside;
      }
      return inside;
    }

    function longestEdgeAngleRad(path){
      let bestLen=-1, bestAng=0;
      for(let i=0; i<path.length; i++){
        const a=path[i], b=path[(i+1)%path.length];
        const dx=b.lng-a.lng, dy=b.lat-a.lat;
        const len=Math.hypot(dx,dy);
        if(len>bestLen){ bestLen=len; bestAng=Math.atan2(dy,dx); }
      }
      return bestAng; // angle from East/X in radians
    }

    function rectCorners(center, wDegLng, hDegLat, angRad){
      const cx=center.lng, cy=center.lat;
      const hw=wDegLng/2, hh=hDegLat/2;

      const pts=[{x:-hw,y:-hh},{x:hw,y:-hh},{x:hw,y:hh},{x:-hw,y:hh}].map(p=>{
        const xr=p.x*Math.cos(angRad)-p.y*Math.sin(angRad);
        const yr=p.x*Math.sin(angRad)+p.y*Math.cos(angRad);
        return {lat:cy+yr, lng:cx+xr};
      });
      return pts;
    }

    function rectFits(areaPath, corners){
      for(const c of corners){
        if(!pointInPoly(c, areaPath)) return false;
      }
      return true;
    }

    function overlapsWalkways(corners){
      for(const w of walkways){
        const wp = polygonToPath(w);
        for(const c of corners){
          if(pointInPoly(c, wp)) return true;
        }
      }
      return false;
    }

    function overlapsExistingPanels(areaObj, corners){
      // simple bbox overlap check (fast)
      const bb = polygonBounds(corners);
      for(const p of areaObj.panels){
        const rbb = polygonBounds(p.__corners);
        const overlap = !(bb.maxLat<rbb.minLat || bb.minLat>rbb.maxLat || bb.maxLng<rbb.minLng || bb.minLng>rbb.maxLng);
        if(overlap) return true;
      }
      return false;
    }

    function updateTotalPanels(){
      let total=0;
      for(const a of areas) total += a.panels.length;
      setStats(`Total panels placed: ${total}`);
    }

    // =========================
    // AUTO-FILL (for selected area)
    // =========================
    function autoFillSelected(){
      if(!selected || selected.type !== "area"){
        alert("Click an AREA polygon to select it first.");
        return;
      }

      const areaObj = selected.ref;
      const areaPath = polygonToPath(areaObj.poly);

      const pLen = parseFloat(document.getElementById("pLen").value);
      const pWid = parseFloat(document.getElementById("pWid").value);
      const gap = parseFloat(document.getElementById("gap").value);
      const setback = parseFloat(document.getElementById("setback").value);

      if(![pLen,pWid,gap,setback].every(Number.isFinite)){
        alert("Check panel inputs."); return;
      }

      const bounds = polygonBounds(areaPath);
      const centerLat = (bounds.minLat + bounds.maxLat)/2;

      const cellWm = pWid + gap;
      const cellHm = pLen + gap;

      const cellW = metersToDegreesLng(cellWm, centerLat);
      const cellH = metersToDegreesLat(cellHm);

      const sbLat = metersToDegreesLat(setback);
      const sbLng = metersToDegreesLng(setback, centerLat);

      const scanMinLat = bounds.minLat + sbLat;
      const scanMaxLat = bounds.maxLat - sbLat;
      const scanMinLng = bounds.minLng + sbLng;
      const scanMaxLng = bounds.maxLng - sbLng;

      if(scanMaxLat <= scanMinLat || scanMaxLng <= scanMinLng){
        alert("Setback too large for this area."); return;
      }

      // rotation
      const rotMode = document.getElementById("rotMode").value;
      let angRad = 0;
      if(rotMode === "none") angRad = 0;
      else if(rotMode === "manual"){
        const deg = parseFloat(document.getElementById("manualAngle").value) || 0;
        angRad = deg * Math.PI/180;
      } else {
        angRad = longestEdgeAngleRad(areaPath);
      }

      const rectW = metersToDegreesLng(pWid, centerLat);
      const rectH = metersToDegreesLat(pLen);

      let placed = 0;
      const maxTries = 90000;
      let tries = 0;

      for(let lat = scanMinLat; lat <= scanMaxLat; lat += cellH){
        for(let lng = scanMinLng; lng <= scanMaxLng; lng += cellW){
          if(tries++ > maxTries) break;

          const center = {lat, lng};
          const corners = rectCorners(center, rectW, rectH, angRad);

          if(!rectFits(areaPath, corners)) continue;
          if(overlapsWalkways(corners)) continue;
          if(overlapsExistingPanels(areaObj, corners)) continue;

          const poly = new google.maps.Polygon({
            paths: corners,
            map,
            strokeColor: "#00bfff",
            strokeOpacity: 0.9,
            strokeWeight: 1,
            fillColor: "#00bfff",
            fillOpacity: 0.25,
            clickable: false
          });
          poly.__corners = corners;
          areaObj.panels.push(poly);
          placed++;
        }
        if(tries > maxTries) break;
      }

      updateTotalPanels();
      setHint(`Auto-fill complete for ${areaObj.id}. Added ${placed} panels.`);
    }

    function clearPanelsSelected(){
      if(!selected || selected.type !== "area"){
        alert("Select an AREA first."); return;
      }
      const areaObj = selected.ref;
      for(const p of areaObj.panels) p.setMap(null);
      areaObj.panels = [];
      updateTotalPanels();
      setHint(`Cleared panels for ${areaObj.id}.`);
    }

    // =========================
    // DELETE / RESET / EXPORT
    // =========================
    function deleteSelected(){
      if(!selected){ alert("Nothing selected."); return; }

      if(selected.type === "area"){
        const a = selected.ref;
        for(const p of a.panels) p.setMap(null);
        a.poly.setMap(null);
        const idx = areas.indexOf(a);
        if(idx >= 0) areas.splice(idx,1);
        unselectAll();
        updateTotalPanels();
        setHint("Deleted selected area.");
      } else {
        const w = selected.ref;
        w.setMap(null);
        const idx = walkways.indexOf(w);
        if(idx >= 0) walkways.splice(idx,1);
        unselectAll();
        setHint("Deleted selected walkway/no-go.");
      }
    }

    function resetEverything(){
      // areas + panels
      for(const a of areas){
        for(const p of a.panels) p.setMap(null);
        a.poly.setMap(null);
      }
      areas.length = 0;

      // walkways
      for(const w of walkways) w.setMap(null);
      walkways.length = 0;

      // marker
      if(pinMarker){ pinMarker.setMap(null); pinMarker = null; }

      // drawing
      drawMode = DRAW_NONE;
      drawingManager.setDrawingMode(null);

      unselectAll();
      updateTotalPanels();
      setHint("Reset complete. Everything cleared.");
    }

    function exportJSON(){
      const out = {
        timestamp: new Date().toISOString(),
        areas: [],
        walkways: [],
        panels: []
      };

      for(const a of areas){
        out.areas.push({ id: a.id, path: polygonToPath(a.poly) });
        for(const p of a.panels){
          out.panels.push({ areaId: a.id, corners: p.__corners });
        }
      }
      for(const w of walkways){
        out.walkways.push({ path: polygonToPath(w) });
      }

      const blob = new Blob([JSON.stringify(out, null, 2)], {type:"application/json"});
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "pv_layout.json";
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);

      setHint("Exported JSON.");
    }

    // =========================
    // DRAWING (This is the good polygon UX you liked)
    // =========================
    function startDraw(mode){
      drawMode = mode;
      drawingManager.setDrawingMode(google.maps.drawing.OverlayType.POLYGON);

      if(mode === DRAW_AREA) setHint("Drawing AREA: click corners, then click first point to close (or double-click).");
      if(mode === DRAW_WALK) setHint("Drawing WALKWAY/NO-GO: draw polygon and close it.");
    }

    function stopDraw(){
      drawMode = DRAW_NONE;
      drawingManager.setDrawingMode(null);
      setHint("Drawing stopped.");
    }

    // =========================
    // INIT MAP
    // =========================
    function initMap() {
      map = new google.maps.Map(document.getElementById("map"), {
        center: { lat: -1.286389, lng: 36.817223 },
        zoom: 20,
        mapTypeId: "satellite",
        disableDoubleClickZoom: true
      });

      drawingManager = new google.maps.drawing.DrawingManager({
        drawingMode: null,
        drawingControl: false,
        polygonOptions: {
          editable: true,
          clickable: true
        }
      });
      drawingManager.setMap(map);

      // overlaycomplete = the reliable "highlighted polygon" behavior
      google.maps.event.addListener(drawingManager, "overlaycomplete", (e) => {
        if (e.type !== google.maps.drawing.OverlayType.POLYGON) return;

        const poly = e.overlay;

        if(drawMode === DRAW_AREA){
          poly.setOptions({
            fillColor: "#00ff88",
            fillOpacity: 0.15,
            strokeColor: "#00ff88",
            strokeWeight: 2,
            editable: true
          });

          const areaObj = { id: `area_${Date.now()}`, poly, panels: [] };
          areas.push(areaObj);

          // click to select
          poly.addListener("click", () => selectArea(areaObj));
          selectArea(areaObj);

          // keep drawing enabled so you can immediately draw next side if you want
          drawingManager.setDrawingMode(google.maps.drawing.OverlayType.POLYGON);
          setHint("Area saved. Click Auto-fill, or draw the next side (previous stays).");
        }

        if(drawMode === DRAW_WALK){
          poly.setOptions({
            fillColor: "#ff3355",
            fillOpacity: 0.22,
            strokeColor: "#ff3355",
            strokeWeight: 2,
            editable: true
          });

          walkways.push(poly);
          poly.addListener("click", () => selectWalkway(poly));
          selectWalkway(poly);

          drawingManager.setDrawingMode(google.maps.drawing.OverlayType.POLYGON);
          setHint("Walkway/no-go saved. Panels will avoid it. Draw another or Auto-fill.");
        }
      });

      // click empty map to unselect
      map.addListener("click", () => unselectAll());

      // UI hooks
      document.getElementById("btnGoCoords").addEventListener("click", goToCoords);
      document.getElementById("coords").addEventListener("keydown", (e) => { if (e.key === "Enter") goToCoords(); });

      document.getElementById("btnDrawArea").addEventListener("click", () => startDraw(DRAW_AREA));
      document.getElementById("btnDrawWalk").addEventListener("click", () => startDraw(DRAW_WALK));
      document.getElementById("btnStopDraw").addEventListener("click", stopDraw);

      document.getElementById("btnFill").addEventListener("click", autoFillSelected);
      document.getElementById("btnClearAreaPanels").addEventListener("click", clearPanelsSelected);
      document.getElementById("btnDeleteSelected").addEventListener("click", deleteSelected);
      document.getElementById("btnReset").addEventListener("click", resetEverything);
      document.getElementById("btnExport").addEventListener("click", exportJSON);

      updateTotalPanels();
      updateSelectedInfo();
      setHint("Ready. Click 'Draw Roof / Ground Area' to start.");
    }
  </script>

  <!-- IMPORTANT:
       1) Put your Google Maps JavaScript API key below.
       2) Ensure Maps JavaScript API is enabled in Google Cloud.
       3) Ensure the key allows your Vercel domain in HTTP referrers. -->
  <script async defer
    src="https://maps.googleapis.com/maps/api/js?key=PASTE_YOUR_MAPS_JS_API_KEY_HERE&libraries=drawing&callback=initMap">
  </script>
</body>
</html>
