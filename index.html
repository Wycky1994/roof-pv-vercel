<!doctype html>
<!--
  PV Layout PRO (Multi Areas + Auto Walkways + Meter-based Auto-Fill)
  Author: Wycliffe Wanyonyi
-->
<html>
<head>
  <meta charset="utf-8" />
  <title>PV Layout PRO (Multi Areas + Auto Walkways + Meter-based Auto-Fill)</title>
  <meta name="author" content="Wycliffe Wanyonyi" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html, body { height: 100%; margin: 0; font-family: Arial, sans-serif; }
    #map { height: 100%; width: 100%; }

    .panel{
      position:absolute; top:12px; left:12px;
      background:rgba(255,255,255,0.94);
      padding:10px 12px; border-radius:12px;
      box-shadow:0 8px 22px rgba(0,0,0,0.18);
      z-index:5; width:430px;
      max-height:calc(100% - 24px);
      overflow:auto;
    }
    .row{ display:flex; gap:8px; margin:8px 0; }
    .row>div{ flex:1; }
    label{ font-size:12px; color:#222; display:block; margin-bottom:4px; }
    input,select{
      width:100%; padding:8px; box-sizing:border-box;
      border-radius:10px; border:1px solid #ccc;
    }
    button{
      width:100%; padding:10px; cursor:pointer; margin-top:8px;
      border-radius:10px; border:1px solid #bbb; background:#f5f5f5;
      font-weight:600;
    }
    button:hover{ background:#eee; }
    button.primary{ background:#111; color:#fff; border:0; }
    button.primary:hover{ background:#000; }
    button.danger{ background:#c62828; color:#fff; border:0; }
    button.danger:hover{ background:#a61f1f; }

    small{ color:#444; line-height:1.35; display:block; margin-top:6px; }
    .pill{
      display:inline-block; padding:3px 8px; border-radius:999px;
      background:#f0f0f0; border:1px solid #ddd; font-size:12px;
      margin-right:6px; margin-top:6px;
    }
    .stats{ margin-top:10px; font-weight:bold; }
    .hint{ font-weight:normal; margin-top:6px; }
    .sectionTitle{
      font-weight:bold; margin-top:10px;
      padding-top:8px; border-top:1px solid #e5e5e5;
    }
    .badge{
      display:inline-block;
      padding:3px 8px;
      border-radius:999px;
      border:1px solid #ddd;
      background:#fafafa;
      font-size:12px;
      margin-left:8px;
    }
  </style>
</head>

<body>
  <div class="panel">
    <div class="sectionTitle" style="border-top:none; padding-top:0; margin-top:0;">
      Find location <span class="badge">Author: Wycliffe Wanyonyi</span>
    </div>

    <div class="row">
      <div style="flex:1.6;">
        <label>Coordinates (lat, lng)</label>
        <input id="coords" type="text" value="-1.2981371, 36.8907759" placeholder="-1.2981371, 36.8907759">
      </div>
      <div style="flex:0.9;">
        <label>&nbsp;</label>
        <button id="btnGoCoords" style="margin-top:0;">Go</button>
      </div>
    </div>
    <small>Paste as <b>lat, lng</b> then click Go.</small>

    <div class="sectionTitle">
      Active Selection <span class="badge" id="selBadge">none</span>
    </div>

    <div class="sectionTitle">Panel / Layout</div>
    <div class="row">
      <div>
        <label>Panel Length (m)</label>
        <input id="pLen" type="number" step="0.001" value="2.279">
      </div>
      <div>
        <label>Panel Width (m)</label>
        <input id="pWid" type="number" step="0.001" value="1.134">
      </div>
    </div>

    <div class="row">
      <div>
        <label>Gap between panels (m)</label>
        <input id="gap" type="number" step="0.001" value="0.02">
      </div>
      <div>
        <label>Edge setback (m)</label>
        <input id="setback" type="number" step="0.01" value="0.30">
      </div>
    </div>

    <div class="row">
      <div>
        <label>Panel Orientation (matches your expectation)</label>
        <select id="orient">
          <option value="auto" selected>Auto (best)</option>
          <option value="portrait">Portrait (long side along roof length)</option>
          <option value="landscape">Landscape (long side across roof)</option>
        </select>
      </div>
      <div>
        <label>Rotation Mode</label>
        <select id="rotMode">
          <option value="auto" selected>Auto (best)</option>
          <option value="manual">Manual angle</option>
          <option value="none">No rotation (0°)</option>
        </select>
      </div>
    </div>

    <div class="row">
      <div>
        <label>Manual angle (deg, from X/East)</label>
        <input id="manualAngle" type="number" step="0.1" value="0">
      </div>
      <div>
        <label>Angle step (deg) (Auto)</label>
        <input id="angleStep" type="number" step="1" value="5">
      </div>
    </div>

    <div class="sectionTitle">Flat roof rack spacing (optional)</div>
    <div class="row">
      <div>
        <label>Mount Type</label>
        <select id="mountType">
          <option value="flush" selected>Flush</option>
          <option value="tilted">Tilted racks</option>
        </select>
      </div>
      <div>
        <label>Roof/Array Tilt (deg)</label>
        <input id="roofTilt" type="number" step="0.1" value="10">
      </div>
    </div>
    <div class="row">
      <div>
        <label>Min sun elevation (deg)</label>
        <input id="minSunEl" type="number" step="0.1" value="20">
      </div>
      <div>
        <label>Extra row gap (m)</label>
        <input id="rowGap" type="number" step="0.01" value="0.20">
      </div>
    </div>

    <div class="sectionTitle">Walkways (Auto)</div>
    <div class="row">
      <div>
        <label>Walkway width (m)</label>
        <input id="walkW" type="number" step="0.1" value="0.6">
      </div>
      <div>
        <label>Spacing (m) for long roofs</label>
        <input id="walkSpacing" type="number" step="0.5" value="6">
      </div>
    </div>
    <div class="row">
      <div><button id="btnAutoWalk">Auto Walkways (Selected AREA)</button></div>
      <div><button id="btnDrawWalk">Draw WALKWAY / NO-GO (Manual)</button></div>
    </div>

    <div class="sectionTitle">Draw / Actions</div>
    <div class="row">
      <div><button id="btnDrawArea">Draw NEW Roof / Ground AREA</button></div>
      <div><button class="primary" id="btnFill">Auto-fill (Selected AREA)</button></div>
    </div>

    <div class="row">
      <div><button id="btnClearPanels">Clear Panels (Selected AREA)</button></div>
      <div><button id="btnDeleteSelected">Delete Selected Shape</button></div>
    </div>

    <div class="row">
      <div><button id="btnExport">Export JSON</button></div>
      <div><button class="danger" id="btnReset">RESET (Clear Everything)</button></div>
    </div>

    <small>
      <span class="pill">1</span> Draw an AREA polygon → click it to select.<br/>
      <span class="pill">2</span> Auto Walkways (optional) → panels avoid them.<br/>
      <span class="pill">3</span> Auto-fill selected area. Draw next roof side: previous stays.
    </small>

    <div id="stats" class="stats"></div>
    <div id="hint" class="hint"></div>
  </div>

  <div id="map"></div>

  <script>
    // =========================
    // GLOBALS
    // =========================
    let map, drawingManager;
    let pinMarker = null;

    const DRAW_NONE = null;
    const DRAW_AREA = "area";
    const DRAW_WALK = "walk";
    let drawMode = DRAW_NONE;

    // Areas: { id, polygon, panels[] }
    const areas = [];
    // Walkways/no-go polygons (global, apply to all areas)
    const walkways = [];

    // Selected: { type: 'area', obj } OR { type:'walk', poly }
    let selected = null;

    function setHint(t){ document.getElementById("hint").innerText = t || ""; }
    function setStats(t){ document.getElementById("stats").innerText = t || ""; }

    function updateSelBadge(){
      const el = document.getElementById("selBadge");
      if(!selected) el.innerText = "none";
      else if(selected.type === "area") el.innerText = selected.obj.id;
      else el.innerText = "walkway/no-go";
    }

    function clearSelectionStyles(){
      for(const a of areas) a.polygon.setOptions({ strokeWeight: 2 });
      for(const w of walkways) w.setOptions({ strokeWeight: 2 });
    }

    function selectArea(areaObj){
      selected = { type:"area", obj: areaObj };
      clearSelectionStyles();
      areaObj.polygon.setOptions({ strokeWeight: 4 });
      updateSelBadge();
      setHint("AREA selected. Auto-fill and/or Auto Walkways are now available.");
    }

    function selectWalk(poly){
      selected = { type:"walk", poly };
      clearSelectionStyles();
      poly.setOptions({ strokeWeight: 4 });
      updateSelBadge();
      setHint("Walkway/no-go selected.");
    }

    function unselectAll(){
      selected = null;
      clearSelectionStyles();
      updateSelBadge();
    }

    // =========================
    // COORDS JUMP
    // =========================
    function goToCoords() {
      const raw = (document.getElementById("coords").value || "").trim();
      const parts = raw.split(/[\s,]+/).filter(Boolean);
      if (parts.length < 2) { alert("Enter coordinates as: -1.2981371, 36.8907759"); return; }

      const lat = parseFloat(parts[0]);
      const lng = parseFloat(parts[1]);
      if (!Number.isFinite(lat) || !Number.isFinite(lng) || lat < -90 || lat > 90 || lng < -180 || lng > 180) {
        alert("Invalid coordinates."); return;
      }

      const pos = new google.maps.LatLng(lat, lng);
      map.panTo(pos);
      map.setZoom(Math.max(map.getZoom() || 18, 20));

      if (pinMarker) pinMarker.setMap(null);
      pinMarker = new google.maps.Marker({ position: pos, map, title: `${lat.toFixed(6)}, ${lng.toFixed(6)}` });

      setHint(`Pinned: ${lat.toFixed(6)}, ${lng.toFixed(6)}.`);
    }

    // =========================
    // GEO UTILS (local meters)
    // =========================
    function latLngToMeters(lat, lng, refLat, refLng) {
      const R = 6378137;
      const dLat = (lat - refLat) * Math.PI / 180;
      const dLng = (lng - refLng) * Math.PI / 180;
      const x = dLng * R * Math.cos(refLat * Math.PI / 180);
      const y = dLat * R;
      return {x, y};
    }

    function metersToLatLng(x, y, refLat, refLng) {
      const R = 6378137;
      const dLat = y / R;
      const dLng = x / (R * Math.cos(refLat * Math.PI / 180));
      const lat = refLat + (dLat * 180 / Math.PI);
      const lng = refLng + (dLng * 180 / Math.PI);
      return {lat, lng};
    }

    function centroid(poly) {
      let a = 0, cx = 0, cy = 0;
      for (let i=0, j=poly.length-1; i<poly.length; j=i++) {
        const p1 = poly[j], p2 = poly[i];
        const f = (p1.x * p2.y - p2.x * p1.y);
        a += f;
        cx += (p1.x + p2.x) * f;
        cy += (p1.y + p2.y) * f;
      }
      a *= 0.5;
      if (Math.abs(a) < 1e-9) {
        const n = poly.length;
        return {
          x: poly.reduce((s,p)=>s+p.x,0)/n,
          y: poly.reduce((s,p)=>s+p.y,0)/n
        };
      }
      cx /= (6*a); cy /= (6*a);
      return {x: cx, y: cy};
    }

    function rotatePoint(p, c, angRad) {
      const dx = p.x - c.x, dy = p.y - c.y;
      const ca = Math.cos(angRad), sa = Math.sin(angRad);
      return { x: c.x + dx*ca - dy*sa, y: c.y + dx*sa + dy*ca };
    }

    function rotatePoly(poly, c, angRad) { return poly.map(p => rotatePoint(p, c, angRad)); }

    function pointInPoly(pt, poly) {
      let inside = false;
      for (let i=0, j=poly.length-1; i<poly.length; j=i++) {
        const xi = poly[i].x, yi = poly[i].y;
        const xj = poly[j].x, yj = poly[j].y;
        const intersect = ((yi > pt.y) !== (yj > pt.y)) &&
          (pt.x < (xj - xi) * (pt.y - yi) / ((yj - yi) + 1e-12) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }

    function distPointToSeg(pt, a, b) {
      const vx = b.x - a.x, vy = b.y - a.y;
      const wx = pt.x - a.x, wy = pt.y - a.y;
      const c1 = vx*wx + vy*wy;
      if (c1 <= 0) return Math.hypot(pt.x - a.x, pt.y - a.y);
      const c2 = vx*vx + vy*vy;
      if (c2 <= c1) return Math.hypot(pt.x - b.x, pt.y - b.y);
      const t = c1 / c2;
      const px = a.x + t*vx, py = a.y + t*vy;
      return Math.hypot(pt.x - px, pt.y - py);
    }

    function minDistToPolyEdges(pt, poly) {
      let minD = Infinity;
      for (let i=0; i<poly.length; i++) {
        const a = poly[i];
        const b = poly[(i+1) % poly.length];
        minD = Math.min(minD, distPointToSeg(pt, a, b));
      }
      return minD;
    }

    function rectCorners(x, y, w, h) {
      return [{x:x,y:y},{x:x+w,y:y},{x:x+w,y:y+h},{x:x,y:y+h}];
    }

    function rectValid(corners, roofPoly, noGoList, setback) {
      for (const c of corners) {
        if (!pointInPoly(c, roofPoly)) return false;
        if (setback > 0) {
          const d = minDistToPolyEdges(c, roofPoly);
          if (d < setback) return false;
        }
      }
      for (const ng of noGoList) {
        for (const c of corners) {
          if (pointInPoly(c, ng)) return false;
        }
      }
      return true;
    }

    function bbox(poly) {
      let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
      for (const p of poly) {
        minX = Math.min(minX, p.x);
        minY = Math.min(minY, p.y);
        maxX = Math.max(maxX, p.x);
        maxY = Math.max(maxY, p.y);
      }
      return {minX, minY, maxX, maxY};
    }

    // Find longest edge direction (deg from East/X), normalized 0..180
    function longestEdgeAngleDegFromX(mPoly){
      let bestLen=-1, bestAng=0;
      for(let i=0; i<mPoly.length; i++){
        const a=mPoly[i], b=mPoly[(i+1)%mPoly.length];
        const dx=b.x-a.x, dy=b.y-a.y;
        const len=Math.hypot(dx,dy);
        if(len>bestLen){
          bestLen=len;
          bestAng = Math.atan2(dy,dx) * 180/Math.PI;
        }
      }
      return ((bestAng % 180) + 180) % 180;
    }

    // =========================
    // RACK ROW SPACING MODEL
    // =========================
    function computeRowPitch(pLen, tiltDeg, minSunElDeg, extraRowGap) {
      const toRad = (d)=>d*Math.PI/180;
      const tilt = toRad(Math.max(0, tiltDeg));
      const minEl = toRad(Math.max(1, minSunElDeg));
      const panelHeight = pLen * Math.sin(tilt);
      const planDepth = pLen * Math.cos(tilt);
      const shadow = panelHeight / Math.tan(minEl);
      return planDepth + shadow + Math.max(0, extraRowGap);
    }

    // =========================
    // SOLVER
    // =========================
    function solveFor(pLen, pWid, anglesDeg, roofM, noGoM, gap, setback, mountType, roofTilt, minSunEl, rowGap) {
      const c = centroid(roofM);
      let best = null;

      for (const angDeg0 of anglesDeg) {
        const angDeg = ((angDeg0 % 180) + 180) % 180;
        const ang = angDeg * Math.PI / 180;

        const roofR = rotatePoly(roofM, c, -ang);
        const noGoR = noGoM.map(poly => rotatePoly(poly, c, -ang));
        const bb = bbox(roofR);

        const stepX = pWid + gap;
        let stepY = pLen + gap;
        if (mountType === "tilted") stepY = computeRowPitch(pLen, roofTilt, minSunEl, rowGap);

        const panels = [];
        for (let y = bb.minY; y + pLen <= bb.maxY; y += stepY) {
          for (let x = bb.minX; x + pWid <= bb.maxX; x += stepX) {
            const cornersR = rectCorners(x, y, pWid, pLen);
            if (!rectValid(cornersR, roofR, noGoR, setback)) continue;
            const cornersM = cornersR.map(pt => rotatePoint(pt, c, +ang));
            panels.push({ angDeg, cornersM });
          }
        }

        if (!best || panels.length > best.count) best = { angDeg, count: panels.length, panels, stepY };
      }
      return best;
    }

    function drawPanels(panelsM, refLat, refLng, targetAreaObj){
      for (const p of panelsM) {
        const llCorners = p.cornersM.map(m => {
          const ll = metersToLatLng(m.x, m.y, refLat, refLng);
          return new google.maps.LatLng(ll.lat, ll.lng);
        });
        const poly = new google.maps.Polygon({
          paths: llCorners,
          map,
          strokeColor: "#00bfff",
          strokeOpacity: 0.9,
          strokeWeight: 1,
          fillColor: "#00bfff",
          fillOpacity: 0.25,
          clickable: false
        });
        targetAreaObj.panels.push(poly);
      }
    }

    function clearPanels(areaObj){
      areaObj.panels.forEach(o => o.setMap(null));
      areaObj.panels = [];
    }

    function totalPanelCount(){
      return areas.reduce((s,a)=>s+a.panels.length,0);
    }

    // =========================
    // AUTO WALKWAYS (heuristic)
    // =========================
    function addWalkwayRectInRotFrame(x, y, w, h, refLat, refLng, cM, angRad){
      // rectangle in rotated frame -> rotate back -> to LatLng -> polygon
      const cornersR = rectCorners(x, y, w, h);
      const cornersM = cornersR.map(pt => rotatePoint(pt, cM, +angRad));
      const llCorners = cornersM.map(m => {
        const ll = metersToLatLng(m.x, m.y, refLat, refLng);
        return new google.maps.LatLng(ll.lat, ll.lng);
      });

      const poly = new google.maps.Polygon({
        paths: llCorners,
        map,
        fillColor: "#ff3355",
        fillOpacity: 0.22,
        strokeColor: "#ff3355",
        strokeWeight: 2,
        editable: true
      });
      walkways.push(poly);
      poly.addListener("click", () => selectWalk(poly));
    }

    function autoWalkwaysSelectedArea(){
      if(!selected || selected.type !== "area"){
        alert("Select an AREA first."); return;
      }

      const areaObj = selected.obj;

      const walkW = parseFloat(document.getElementById("walkW").value);
      const spacing = parseFloat(document.getElementById("walkSpacing").value);
      if(!Number.isFinite(walkW) || walkW <= 0.1){ alert("Walkway width invalid."); return; }
      if(!Number.isFinite(spacing) || spacing < 2){ alert("Spacing invalid."); return; }

      const roofPathLL = areaObj.polygon.getPath().getArray();
      const refLat = roofPathLL[0].lat();
      const refLng = roofPathLL[0].lng();
      const roofM = roofPathLL.map(ll => latLngToMeters(ll.lat(), ll.lng(), refLat, refLng));
      const cM = centroid(roofM);

      // Use same "auto" direction: longest edge
      const preferredDeg = longestEdgeAngleDegFromX(roofM);
      const angRad = preferredDeg * Math.PI/180;

      // rotate roof to axis frame
      const roofR = rotatePoly(roofM, cM, -angRad);
      const bb = bbox(roofR);

      const width = (bb.maxX - bb.minX);
      const height = (bb.maxY - bb.minY);

      // Heuristic:
      // - If roof is very long in X, add cross-walkways in Y every spacing
      // - If roof is very long in Y, add cross-walkways in X every spacing
      // - If extremely long, add a central corridor along long axis
      let added = 0;

      const longAxisIsX = width >= height;
      const longLen = longAxisIsX ? width : height;
      const shortLen = longAxisIsX ? height : width;

      // central corridor (only if huge long roof)
      if(longLen >= 20 && shortLen >= (walkW * 2.2)){
        if(longAxisIsX){
          const yMid = (bb.minY + bb.maxY)/2 - walkW/2;
          addWalkwayRectInRotFrame(bb.minX, yMid, width, walkW, refLat, refLng, cM, angRad);
        } else {
          const xMid = (bb.minX + bb.maxX)/2 - walkW/2;
          addWalkwayRectInRotFrame(xMid, bb.minY, walkW, height, refLat, refLng, cM, angRad);
        }
        added++;
      }

      // periodic cross-walkways
      if(longLen >= 12){
        const count = Math.floor(longLen / spacing);
        if(count >= 1){
          for(let k=1; k<=count; k++){
            const t = k*spacing;
            if(longAxisIsX){
              // cross walkway is vertical strip in X at position
              const x = bb.minX + t - (walkW/2);
              if(x <= bb.minX + 0.5 || x >= bb.maxX - 0.5) continue;
              addWalkwayRectInRotFrame(x, bb.minY, walkW, height, refLat, refLng, cM, angRad);
            } else {
              // cross walkway is horizontal strip in Y at position
              const y = bb.minY + t - (walkW/2);
              if(y <= bb.minY + 0.5 || y >= bb.maxY - 0.5) continue;
              addWalkwayRectInRotFrame(bb.minX, y, width, walkW, refLat, refLng, cM, angRad);
            }
            added++;
          }
        }
      }

      if(added === 0){
        setHint("Auto Walkways: area too small for auto corridors. Use manual walkway or lower spacing.");
      } else {
        setHint(`Auto Walkways added: ${added}. Panels will avoid them. Re-run Auto-fill.`);
      }
      setStats(`Walkways: ${walkways.length} | TOTAL panels: ${totalPanelCount()}`);
    }

    // =========================
    // AUTO-FILL (Selected area)
    // =========================
    function autoFillSelectedArea(){
      if(!selected || selected.type !== "area"){
        alert("Click an AREA polygon to select it first.");
        return;
      }

      const areaObj = selected.obj;
      clearPanels(areaObj);

      const inp = {
        pLen0: parseFloat(document.getElementById("pLen").value),
        pWid0: parseFloat(document.getElementById("pWid").value),
        gap: parseFloat(document.getElementById("gap").value),
        setback: parseFloat(document.getElementById("setback").value),
        orient: document.getElementById("orient").value,
        rotMode: document.getElementById("rotMode").value,
        manualAngle: parseFloat(document.getElementById("manualAngle").value),
        angleStep: Math.max(1, parseFloat(document.getElementById("angleStep").value)),
        mountType: document.getElementById("mountType").value,
        roofTilt: parseFloat(document.getElementById("roofTilt").value),
        minSunEl: parseFloat(document.getElementById("minSunEl").value),
        rowGap: parseFloat(document.getElementById("rowGap").value)
      };

      if(![inp.pLen0, inp.pWid0, inp.gap, inp.setback, inp.angleStep].every(Number.isFinite)){
        alert("Check your numeric inputs."); return;
      }

      const roofPathLL = areaObj.polygon.getPath().getArray();
      const refLat = roofPathLL[0].lat();
      const refLng = roofPathLL[0].lng();

      const roofM = roofPathLL.map(ll => latLngToMeters(ll.lat(), ll.lng(), refLat, refLng));

      // Global walkways/no-go apply to this area
      const noGoM = walkways.map(pg =>
        pg.getPath().getArray().map(ll => latLngToMeters(ll.lat(), ll.lng(), refLat, refLng))
      );

      // ✅ ORIENTATION MAPPING UPDATED:
      // Portrait = long side along roof length / fill direction (what you expect)
      // Landscape = long side across roof
      const candidates = [];
      if (inp.orient === "portrait") {
        // portrait -> width gets LONG side (along X in rotated frame)
        candidates.push({name:"portrait", pLen: inp.pWid0, pWid: inp.pLen0});
      } else if (inp.orient === "landscape") {
        candidates.push({name:"landscape", pLen: inp.pLen0, pWid: inp.pWid0});
      } else {
        // auto: try both
        candidates.push({name:"portrait",  pLen: inp.pWid0, pWid: inp.pLen0});
        candidates.push({name:"landscape", pLen: inp.pLen0, pWid: inp.pWid0});
      }

      // angles
      let anglesDeg = [0];
      if (inp.rotMode === "none") {
        anglesDeg = [0];
      } else if (inp.rotMode === "manual") {
        anglesDeg = [((inp.manualAngle % 180) + 180) % 180];
      } else {
        // Auto: bias around longest edge direction of THIS area, then scan
        const preferred = longestEdgeAngleDegFromX(roofM);
        const step = inp.angleStep;
        anglesDeg = [];
        for (let d=-30; d<=30; d+=step) anglesDeg.push((((preferred + d) % 180) + 180) % 180);
        for (let a=0; a<180; a+=step) anglesDeg.push(a);
        anglesDeg = Array.from(new Set(anglesDeg.map(v => +v.toFixed(4))));
      }

      // solve best
      let bestOverall = null;
      for (const cand of candidates) {
        const best = solveFor(
          cand.pLen, cand.pWid, anglesDeg,
          roofM, noGoM,
          inp.gap, inp.setback,
          inp.mountType, inp.roofTilt, inp.minSunEl, inp.rowGap
        );
        if (!bestOverall || best.count > bestOverall.count) {
          bestOverall = {
            orientation: cand.name,
            pLen: cand.pLen,
            pWid: cand.pWid,
            angDeg: best.angDeg,
            panels: best.panels,
            count: best.count,
            rowPitchY: best.stepY
          };
        }
      }

      if (!bestOverall || bestOverall.count === 0) {
        setStats(`No panels could be placed for ${areaObj.id}. Reduce setback/gap, or redraw polygon.`);
        setHint("");
        return;
      }

      drawPanels(bestOverall.panels, refLat, refLng, areaObj);

      const rowPitchTxt = (inp.mountType === "tilted") ? ` | Row pitch: ${bestOverall.rowPitchY.toFixed(2)} m` : "";
      setStats(`Selected ${areaObj.id} → Panels: ${bestOverall.count} | ${bestOverall.orientation} | Rotation: ${bestOverall.angDeg.toFixed(1)}°`
        + rowPitchTxt + ` | Walkways: ${walkways.length} | TOTAL: ${totalPanelCount()}`);
      setHint("If you add walkways, re-run Auto-fill to apply them.");
    }

    function clearSelectedPanels(){
      if(!selected || selected.type !== "area"){ alert("Select an AREA first."); return; }
      clearPanels(selected.obj);
      setStats(`Cleared panels for ${selected.obj.id}. TOTAL: ${totalPanelCount()}`);
      setHint("");
    }

    function deleteSelected(){
      if(!selected){ alert("Nothing selected."); return; }

      if(selected.type === "area"){
        const a = selected.obj;
        clearPanels(a);
        a.polygon.setMap(null);
        const idx = areas.indexOf(a);
        if(idx >= 0) areas.splice(idx,1);
        unselectAll();
        setStats(`Deleted area. TOTAL panels: ${totalPanelCount()}`);
      } else {
        const w = selected.poly;
        w.setMap(null);
        const idx = walkways.indexOf(w);
        if(idx >= 0) walkways.splice(idx,1);
        unselectAll();
        setStats(`Deleted walkway/no-go. TOTAL panels: ${totalPanelCount()}`);
      }
      setHint("");
    }

    function resetAll(){
      for(const a of areas){
        clearPanels(a);
        a.polygon.setMap(null);
      }
      areas.length = 0;

      for(const w of walkways) w.setMap(null);
      walkways.length = 0;

      if(pinMarker){ pinMarker.setMap(null); pinMarker=null; }

      unselectAll();
      drawingManager.setDrawingMode(null);
      drawMode = DRAW_NONE;

      setStats("");
      setHint("Reset complete.");
    }

    function exportJSON(){
      const out = {
        author: "Wycliffe Wanyonyi",
        timestamp: new Date().toISOString(),
        areas: areas.map(a => ({
          id: a.id,
          polygon: a.polygon.getPath().getArray().map(ll => ({lat: ll.lat(), lng: ll.lng()})),
          panels: a.panels.map(p => p.getPath().getArray().map(ll => ({lat: ll.lat(), lng: ll.lng()})))
        })),
        walkways: walkways.map(w => w.getPath().getArray().map(ll => ({lat: ll.lat(), lng: ll.lng()}))),
        total_panels: totalPanelCount()
      };

      const blob = new Blob([JSON.stringify(out, null, 2)], {type:"application/json"});
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "pv_layout_multi.json";
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);

      setHint("Exported JSON.");
    }

    // =========================
    // INIT MAP + DRAWING
    // =========================
    function initMap() {
      map = new google.maps.Map(document.getElementById("map"), {
        center: { lat: -1.286389, lng: 36.817223 },
        zoom: 20,
        mapTypeId: "satellite",
        disableDoubleClickZoom: true
      });

      drawingManager = new google.maps.drawing.DrawingManager({
        drawingMode: null,
        drawingControl: false,
        polygonOptions: { editable: true, clickable: true }
      });
      drawingManager.setMap(map);

      google.maps.event.addListener(drawingManager, "overlaycomplete", (e) => {
        if (e.type !== google.maps.drawing.OverlayType.POLYGON) return;

        const poly = e.overlay;

        if (drawMode === DRAW_AREA) {
          poly.setOptions({
            fillColor: "#00ff88",
            fillOpacity: 0.15,
            strokeColor: "#00ff88",
            strokeWeight: 2,
            editable: true
          });

          const areaObj = { id: `area_${Date.now()}`, polygon: poly, panels: [] };
          areas.push(areaObj);

          poly.addListener("click", () => selectArea(areaObj));
          selectArea(areaObj);

          drawingManager.setDrawingMode(null);
          drawMode = DRAW_NONE;

          setHint("Area saved. You can Auto Walkways or Auto-fill now.");
          setStats(`Areas: ${areas.length} | Walkways: ${walkways.length} | TOTAL panels: ${totalPanelCount()}`);
        }

        if (drawMode === DRAW_WALK) {
          poly.setOptions({
            fillColor: "#ff3355",
            fillOpacity: 0.22,
            strokeColor: "#ff3355",
            strokeWeight: 2,
            editable: true
          });

          walkways.push(poly);
          poly.addListener("click", () => selectWalk(poly));
          selectWalk(poly);

          drawingManager.setDrawingMode(null);
          drawMode = DRAW_NONE;

          setHint("Walkway/no-go saved. Panels will avoid it. Re-run Auto-fill.");
          setStats(`Walkways: ${walkways.length} | TOTAL panels: ${totalPanelCount()}`);
        }
      });

      map.addListener("click", () => unselectAll());

      // UI hooks
      document.getElementById("btnGoCoords").addEventListener("click", goToCoords);
      document.getElementById("coords").addEventListener("keydown", (e) => { if (e.key === "Enter") goToCoords(); });

      document.getElementById("btnDrawArea").addEventListener("click", () => {
        drawMode = DRAW_AREA;
        drawingManager.setDrawingMode(google.maps.drawing.OverlayType.POLYGON);
        setHint("Draw AREA polygon: click corners, then click first point to close.");
      });

      document.getElementById("btnDrawWalk").addEventListener("click", () => {
        drawMode = DRAW_WALK;
        drawingManager.setDrawingMode(google.maps.drawing.OverlayType.POLYGON);
        setHint("Draw WALKWAY/NO-GO polygon and close it.");
      });

      document.getElementById("btnAutoWalk").addEventListener("click", autoWalkwaysSelectedArea);

      document.getElementById("btnFill").addEventListener("click", autoFillSelectedArea);
      document.getElementById("btnClearPanels").addEventListener("click", clearSelectedPanels);
      document.getElementById("btnDeleteSelected").addEventListener("click", deleteSelected);
      document.getElementById("btnReset").addEventListener("click", resetAll);
      document.getElementById("btnExport").addEventListener("click", exportJSON);

      updateSelBadge();
      setHint("Ready. Draw an AREA, click it to select, then Auto Walkways (optional) and Auto-fill.");
    }
  </script>
  </script>
  <!-- Replace YOUR_MAPS_JS_KEY_HERE with your temporary key -->
 <script async defer
    src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCjYkseGZMK9Ej_NiWsMZwsL72MPtIur3g&libraries=drawing&callback=initMap">
  </script>
</body>
</html>
